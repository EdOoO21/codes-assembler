|                      |       |
|----------------------|-------|
| **Time limit:**      | `1 s` |
| **Real time limit:** | `5 s` |
| **Memory limit:**    | `64M` |


### Problem sm02-5: asm/algorithms/dlinko

Напишите функцию supersum, складывающую беззнаковые "длинные" little-endian числа C = A + B.

В регистре rax передается адрес первого байта числа A, в rbx - числа B, в rcx - числа С.

В esi лежит размер числа A, в edi размер числа B в байтах.

Функция должна вернуть в регистре eax `1 + индекс последнего ненулевого байта числа C` (иными
словами, размер числа C).

Размер числа 0 - 0.

Гарантируется, что размер буфера C > max(размер A, размер B).

Не забывайте сохранять значения регистров, которые нельзя портить.

Флаги процессора можно сохранять и восстанавливать инструкциями pushf и popf.

Входные числа могут содержать старшие нулевые байты.

Вы можете протестировать функцию со [следующими
файлами](https://gist.github.com/ObjatieGroba/cf373ad19998e8f04701997355d5f396)

### Examples

#### Input

    
    
    3 1
    abcdef
    ff

#### Output

    
    
    aaceef

